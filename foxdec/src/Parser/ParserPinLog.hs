{-# OPTIONS_HADDOCK hide #-}


-- Parser that can be used to read logs generated by PIN tool.
--
-- Example input:
--
--
--
{--
Main Image Loaded: /usr/bin/wc, Base Address: 0x555555554000

Section: .text, Address: 0x555555556800, Size: 21218
Section: .rodata, Address: 0x55555555c000, Size: 5196
...
...
# RIP, MemAddr, RSP
0x5555555572b1, 0x7fffffffdde8, 0x7fffffffddf0
0x5555555572b2, 0x7fffffffdde0, 0x7fffffffdde8
...
...
--}
module Parser.ParserPinLog where

import Text.Parsec.Token
import Text.Parsec.Char (hexDigit)
import Text.ParserCombinators.Parsec
import Text.ParserCombinators.Parsec.Number
import qualified Data.IntMap as IM
import Data.Word (Word8)
import qualified Data.Map as M
import qualified Data.Set as S
import Numeric (readHex,showHex)
import Data.Char
import Data.List
import Data.Word
import Control.Monad (void)

data PinLog = PinLog {
  name :: String,
  base :: Word64,
  sections :: [(String, Word64,Word64)],
  log_lines :: M.Map Word64 (S.Set (Word64,Word64))
 }

instance Show PinLog where
  show (PinLog name base sections log_lines) = "PinLog of " ++ name ++ " (base = " ++ showHex base "" ++ ")\n" ++ show_sections sections ++ "\n" ++ show_log_lines log_lines
   where
    show_sections sections = intercalate "\n" $ map show_section sections
    show_section (name,address,size) = "Section: " ++ name ++ ", Address: " ++ showHex address "" ++ ", Size: " ++ show size

    show_log_lines log_lines = intercalate "\n" $ map show_log_line $ M.toList $ log_lines
    show_log_line (rip,observations) = showHex rip "" ++ ": " ++ (intercalate ";" $ map (\(addr,rsp) -> showHex addr "" ++ ", " ++ showHex rsp "") $ S.toList observations)


hex = do
  string "0x"
  digits <- many1 hexDigit
  return $ fst $ head $ readHex digits

header = do
  string "Main Image Loaded:"
  spaces
  binaryName <- manyTill anyChar (try (string ","))
  spaces
  string "Base Address:"
  spaces
  baseAddress <- hex
  eol
  return (binaryName, baseAddress)

section_header = do
  string "Section:"
  spaces
  sectionName <- manyTill anyChar (try (string ","))
  spaces
  string "Address:"
  spaces
  address <- hex
  string ","
  spaces
  string "Size:"
  spaces
  size <- read <$> many1 digit
  eol
  return (sectionName, address, size)

eol = void (char '\n') <|> eof

comment = do
  string "#"
  skipMany (noneOf "\n")
  eol
  
log_line = do
  rip <- hex
  string ","
  spaces
  address <- hex
  string ","
  spaces
  rsp <- hex
  eol
  return (rip,address,rsp)


pin_log = do
  (binaryName, baseAddress) <- header
  many eol
  sections <- many section_header
  comment
  log_lines <- mk_log baseAddress <$> many log_line
  return $ PinLog binaryName baseAddress sections log_lines
 where
  mk_log baseAddress = M.unionsWith S.union . map (mk_log_entry baseAddress)
  mk_log_entry baseAddress (rip,address,rsp) = M.singleton (rip - baseAddress) $ S.singleton (address,rsp)



-- The parse function.
-- Takes as input a filename f and produces a PinLog
parse_pin_log :: String -> IO (Either ParseError PinLog)
parse_pin_log f = parseFromFile pin_log f









